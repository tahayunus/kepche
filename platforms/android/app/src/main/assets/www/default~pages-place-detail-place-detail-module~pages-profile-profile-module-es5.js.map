{"version":3,"sources":["./node_modules/angular-mentions/fesm2015/angular-mentions.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+J;AAChH;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,gCAAgC;AAChC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iBAAiB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,qCAAqC,iBAAiB;AACtD,qFAAqF,YAAY;AACjG;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB,SAAS,OAAO,aAAa,aAAa,WAAW,eAAe,eAAe,kBAAkB,cAAc,cAAc,gBAAgB,gBAAgB,sBAAsB,4BAA4B,iCAAiC,oBAAoB,cAAc,cAAc,mBAAmB,kBAAkB,WAAW,gBAAgB,cAAc,mBAAmB,mBAAmB,6BAA6B,SAAS,kBAAkB,WAAW,qBAAqB,yBAAyB,UAAU,iBAAiB,cAAc,YAAY,iBAAiB,cAAc,SAAS,aAAa,kBAAkB,YAAY,SAAS,kBAAkB;AACtuB,aAAa;AACb;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,oBAAoB,OAAO,mDAAK,EAAE;AAClC,iBAAiB,OAAO,oDAAM,EAAE;AAChC,YAAY,OAAO,uDAAS,kBAAkB,eAAe,IAAI;AACjE,2BAA2B,OAAO,uDAAS,iCAAiC,eAAe,IAAI;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAY;AAC1C;AACA,gCAAgC,0DAAY;AAC5C;AACA,0BAA0B,0DAAY;AACtC,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,sEAAwB,EAAE;AACtC,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,eAAe,OAAO,mDAAK,sBAAsB;AACjD,qBAAqB,OAAO,mDAAK,EAAE;AACnC,2BAA2B,OAAO,mDAAK,EAAE;AACzC,kBAAkB,OAAO,oDAAM,EAAE;AACjC,oBAAoB,OAAO,oDAAM,EAAE;AACnC,cAAc,OAAO,oDAAM,EAAE;AAC7B,cAAc,OAAO,oDAAM,EAAE;AAC7B;;AAEA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEuE;AACvE","file":"default~pages-place-detail-place-detail-module~pages-profile-profile-module-es5.js","sourcesContent":["import { EventEmitter, Component, ElementRef, Input, Output, ViewChild, Directive, ComponentFactoryResolver, ViewContainerRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n// configuration structure, backwards compatible with earlier versions\n\n// DOM element manipulation functions...\n//\nfunction setValue(el, value) {\n    //console.log(\"setValue\", el.nodeName, \"[\"+value+\"]\");\n    if (isInputOrTextAreaElement(el)) {\n        el.value = value;\n    }\n    else {\n        el.textContent = value;\n    }\n}\nfunction getValue(el) {\n    return isInputOrTextAreaElement(el) ? el.value : el.textContent;\n}\nfunction insertValue(el, start, end, text, iframe, noRecursion = false) {\n    //console.log(\"insertValue\", el.nodeName, start, end, \"[\"+text+\"]\", el);\n    if (isTextElement(el)) {\n        let val = getValue(el);\n        setValue(el, val.substring(0, start) + text + val.substring(end, val.length));\n        setCaretPosition(el, start + text.length, iframe);\n    }\n    else if (!noRecursion) {\n        let selObj = getWindowSelection(iframe);\n        if (selObj && selObj.rangeCount > 0) {\n            var selRange = selObj.getRangeAt(0);\n            var position = selRange.startOffset;\n            var anchorNode = selObj.anchorNode;\n            // if (text.endsWith(' ')) {\n            //   text = text.substring(0, text.length-1) + '\\xA0';\n            // }\n            insertValue(anchorNode, position - (end - start), position, text, iframe, true);\n        }\n    }\n}\nfunction isInputOrTextAreaElement(el) {\n    return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA');\n}\n;\nfunction isTextElement(el) {\n    return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA' || el.nodeName == '#text');\n}\n;\nfunction setCaretPosition(el, pos, iframe = null) {\n    //console.log(\"setCaretPosition\", pos, el, iframe==null);\n    if (isInputOrTextAreaElement(el) && el.selectionStart) {\n        el.focus();\n        el.setSelectionRange(pos, pos);\n    }\n    else {\n        let range = getDocument(iframe).createRange();\n        range.setStart(el, pos);\n        range.collapse(true);\n        let sel = getWindowSelection(iframe);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\nfunction getCaretPosition(el, iframe = null) {\n    //console.log(\"getCaretPosition\", el);\n    if (isInputOrTextAreaElement(el)) {\n        var val = el.value;\n        return val.slice(0, el.selectionStart).length;\n    }\n    else {\n        var selObj = getWindowSelection(iframe); //window.getSelection();\n        if (selObj.rangeCount > 0) {\n            var selRange = selObj.getRangeAt(0);\n            var preCaretRange = selRange.cloneRange();\n            preCaretRange.selectNodeContents(el);\n            preCaretRange.setEnd(selRange.endContainer, selRange.endOffset);\n            var position = preCaretRange.toString().length;\n            return position;\n        }\n    }\n}\n// Based on ment.io functions...\n//\nfunction getDocument(iframe) {\n    if (!iframe) {\n        return document;\n    }\n    else {\n        return iframe.contentWindow.document;\n    }\n}\nfunction getWindowSelection(iframe) {\n    if (!iframe) {\n        return window.getSelection();\n    }\n    else {\n        return iframe.contentWindow.getSelection();\n    }\n}\nfunction getContentEditableCaretCoords(ctx) {\n    let markerTextChar = '\\ufeff';\n    let markerId = 'sel_' + new Date().getTime() + '_' + Math.random().toString().substr(2);\n    let doc = getDocument(ctx ? ctx.iframe : null);\n    let sel = getWindowSelection(ctx ? ctx.iframe : null);\n    let prevRange = sel.getRangeAt(0);\n    // create new range and set postion using prevRange\n    let range = doc.createRange();\n    range.setStart(sel.anchorNode, prevRange.startOffset);\n    range.setEnd(sel.anchorNode, prevRange.startOffset);\n    range.collapse(false);\n    // Create the marker element containing a single invisible character\n    // using DOM methods and insert it at the position in the range\n    let markerEl = doc.createElement('span');\n    markerEl.id = markerId;\n    markerEl.appendChild(doc.createTextNode(markerTextChar));\n    range.insertNode(markerEl);\n    sel.removeAllRanges();\n    sel.addRange(prevRange);\n    let coordinates = {\n        left: 0,\n        top: markerEl.offsetHeight\n    };\n    localToRelativeCoordinates(ctx, markerEl, coordinates);\n    markerEl.parentNode.removeChild(markerEl);\n    return coordinates;\n}\nfunction localToRelativeCoordinates(ctx, element, coordinates) {\n    let obj = element;\n    let iframe = ctx ? ctx.iframe : null;\n    while (obj) {\n        if (ctx.parent != null && ctx.parent == obj) {\n            break;\n        }\n        coordinates.left += obj.offsetLeft + obj.clientLeft;\n        coordinates.top += obj.offsetTop + obj.clientTop;\n        obj = obj.offsetParent;\n        if (!obj && iframe) {\n            obj = iframe;\n            iframe = null;\n        }\n    }\n    obj = element;\n    iframe = ctx ? ctx.iframe : null;\n    while (obj !== getDocument(null).body && obj != null) {\n        if (ctx.parent != null && ctx.parent == obj) {\n            break;\n        }\n        if (obj.scrollTop && obj.scrollTop > 0) {\n            coordinates.top -= obj.scrollTop;\n        }\n        if (obj.scrollLeft && obj.scrollLeft > 0) {\n            coordinates.left -= obj.scrollLeft;\n        }\n        obj = obj.parentNode;\n        if (!obj && iframe) {\n            obj = iframe;\n            iframe = null;\n        }\n    }\n}\n\n/* From: https://github.com/component/textarea-caret-position */\n/* jshint browser: true */\n// (function () {\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nvar properties = [\n    'direction',\n    'boxSizing',\n    'width',\n    'height',\n    'overflowX',\n    'overflowY',\n    'borderTopWidth',\n    'borderRightWidth',\n    'borderBottomWidth',\n    'borderLeftWidth',\n    'borderStyle',\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n    'fontStyle',\n    'fontVariant',\n    'fontWeight',\n    'fontStretch',\n    'fontSize',\n    'fontSizeAdjust',\n    'lineHeight',\n    'fontFamily',\n    'textAlign',\n    'textTransform',\n    'textIndent',\n    'textDecoration',\n    'letterSpacing',\n    'wordSpacing',\n    'tabSize',\n    'MozTabSize'\n];\nvar isBrowser = (typeof window !== 'undefined');\nvar isFirefox = (isBrowser && window['mozInnerScreenX'] != null);\nfunction getCaretCoordinates(element, position, options) {\n    if (!isBrowser) {\n        throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n    }\n    var debug = options && options.debug || false;\n    if (debug) {\n        var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n        if (el)\n            el.parentNode.removeChild(el);\n    }\n    // The mirror div will replicate the textarea's style\n    var div = document.createElement('div');\n    div.id = 'input-textarea-caret-position-mirror-div';\n    document.body.appendChild(div);\n    var style = div.style;\n    var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle; // currentStyle for IE < 9\n    var isInput = element.nodeName === 'INPUT';\n    // Default textarea styles\n    style.whiteSpace = 'pre-wrap';\n    if (!isInput)\n        style.wordWrap = 'break-word'; // only for textarea-s\n    // Position off-screen\n    style.position = 'absolute'; // required to return coordinates properly\n    if (!debug)\n        style.visibility = 'hidden'; // not 'display: none' because we want rendering\n    // Transfer the element's properties to the div\n    properties.forEach(function (prop) {\n        if (isInput && prop === 'lineHeight') {\n            // Special case for <input>s because text is rendered centered and line height may be != height\n            if (computed.boxSizing === \"border-box\") {\n                var height = parseInt(computed.height);\n                var outerHeight = parseInt(computed.paddingTop) +\n                    parseInt(computed.paddingBottom) +\n                    parseInt(computed.borderTopWidth) +\n                    parseInt(computed.borderBottomWidth);\n                var targetHeight = outerHeight + parseInt(computed.lineHeight);\n                if (height > targetHeight) {\n                    style.lineHeight = height - outerHeight + \"px\";\n                }\n                else if (height === targetHeight) {\n                    style.lineHeight = computed.lineHeight;\n                }\n                else {\n                    style.lineHeight = '0';\n                }\n            }\n            else {\n                style.lineHeight = computed.height;\n            }\n        }\n        else {\n            style[prop] = computed[prop];\n        }\n    });\n    if (isFirefox) {\n        // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n        if (element.scrollHeight > parseInt(computed.height))\n            style.overflowY = 'scroll';\n    }\n    else {\n        style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n    }\n    div.textContent = element.value.substring(0, position);\n    // The second special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput)\n        div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n    var span = document.createElement('span');\n    // Wrapping must be replicated *exactly*, including when a long word gets\n    // onto the next line, with whitespace at the end of the line before (#7).\n    // The  *only* reliable way to do that is to copy the *entire* rest of the\n    // textarea's content into the <span> created at the caret position.\n    // For inputs, just '.' would be enough, but no need to bother.\n    span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all\n    div.appendChild(span);\n    var coordinates = {\n        top: span.offsetTop + parseInt(computed['borderTopWidth']),\n        left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\n        height: parseInt(computed['lineHeight'])\n    };\n    if (debug) {\n        span.style.backgroundColor = '#aaa';\n    }\n    else {\n        document.body.removeChild(div);\n    }\n    return coordinates;\n}\n// if (typeof module != 'undefined' && typeof module.exports != 'undefined') {\n//   module.exports = getCaretCoordinates;\n// } else if(isBrowser) {\n//   window.getCaretCoordinates = getCaretCoordinates;\n// }\n// }());\n\n/**\n * Angular Mentions.\n * https://github.com/dmacfarlane/angular-mentions\n *\n * Copyright (c) 2016 Dan MacFarlane\n */\nclass MentionListComponent {\n    constructor(element) {\n        this.element = element;\n        this.labelKey = 'label';\n        this.itemClick = new EventEmitter();\n        this.items = [];\n        this.activeIndex = 0;\n        this.hidden = false;\n        this.dropUp = false;\n        this.styleOff = false;\n        this.coords = { top: 0, left: 0 };\n        this.offset = 0;\n    }\n    ngAfterContentChecked() {\n        if (!this.itemTemplate) {\n            this.itemTemplate = this.defaultItemTemplate;\n        }\n    }\n    // lots of confusion here between relative coordinates and containers\n    position(nativeParentElement, iframe = null) {\n        if (isInputOrTextAreaElement(nativeParentElement)) {\n            // parent elements need to have postition:relative for this to work correctly?\n            this.coords = getCaretCoordinates(nativeParentElement, nativeParentElement.selectionStart, null);\n            this.coords.top = nativeParentElement.offsetTop + this.coords.top - nativeParentElement.scrollTop;\n            this.coords.left = nativeParentElement.offsetLeft + this.coords.left - nativeParentElement.scrollLeft;\n            // getCretCoordinates() for text/input elements needs an additional offset to position the list correctly\n            this.offset = this.getBlockCursorDimensions(nativeParentElement).height;\n        }\n        else if (iframe) {\n            let context = { iframe: iframe, parent: iframe.offsetParent };\n            this.coords = getContentEditableCaretCoords(context);\n        }\n        else {\n            let doc = document.documentElement;\n            let scrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n            let scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n            // bounding rectangles are relative to view, offsets are relative to container?\n            let caretRelativeToView = getContentEditableCaretCoords({ iframe: iframe });\n            let parentRelativeToContainer = nativeParentElement.getBoundingClientRect();\n            this.coords.top = caretRelativeToView.top - parentRelativeToContainer.top + nativeParentElement.offsetTop - scrollTop;\n            this.coords.left = caretRelativeToView.left - parentRelativeToContainer.left + nativeParentElement.offsetLeft - scrollLeft;\n        }\n        // set the default/inital position\n        this.positionElement();\n    }\n    get activeItem() {\n        return this.items[this.activeIndex];\n    }\n    activateNextItem() {\n        // adjust scrollable-menu offset if the next item is out of view\n        let listEl = this.list.nativeElement;\n        let activeEl = listEl.getElementsByClassName('active').item(0);\n        if (activeEl) {\n            let nextLiEl = activeEl.nextSibling;\n            if (nextLiEl && nextLiEl.nodeName == \"LI\") {\n                let nextLiRect = nextLiEl.getBoundingClientRect();\n                if (nextLiRect.bottom > listEl.getBoundingClientRect().bottom) {\n                    listEl.scrollTop = nextLiEl.offsetTop + nextLiRect.height - listEl.clientHeight;\n                }\n            }\n        }\n        // select the next item\n        this.activeIndex = Math.max(Math.min(this.activeIndex + 1, this.items.length - 1), 0);\n    }\n    activatePreviousItem() {\n        // adjust the scrollable-menu offset if the previous item is out of view\n        let listEl = this.list.nativeElement;\n        let activeEl = listEl.getElementsByClassName('active').item(0);\n        if (activeEl) {\n            let prevLiEl = activeEl.previousSibling;\n            if (prevLiEl && prevLiEl.nodeName == \"LI\") {\n                let prevLiRect = prevLiEl.getBoundingClientRect();\n                if (prevLiRect.top < listEl.getBoundingClientRect().top) {\n                    listEl.scrollTop = prevLiEl.offsetTop;\n                }\n            }\n        }\n        // select the previous item\n        this.activeIndex = Math.max(Math.min(this.activeIndex - 1, this.items.length - 1), 0);\n    }\n    // reset for a new mention search\n    reset() {\n        this.list.nativeElement.scrollTop = 0;\n        this.checkBounds();\n    }\n    // final positioning is done after the list is shown (and the height and width are known)\n    // ensure it's in the page bounds\n    checkBounds() {\n        let left = this.coords.left, top = this.coords.top, dropUp = this.dropUp;\n        const bounds = this.list.nativeElement.getBoundingClientRect();\n        // if off right of page, align right\n        if (bounds.left + bounds.width > window.innerWidth) {\n            left -= bounds.left + bounds.width - window.innerWidth + 10;\n        }\n        // if more than half off the bottom of the page, force dropUp\n        // if ((bounds.top+bounds.height/2)>window.innerHeight) {\n        //   dropUp = true;\n        // }\n        // if top is off page, disable dropUp\n        if (bounds.top < 0) {\n            dropUp = false;\n        }\n        // set the revised/final position\n        this.positionElement(left, top, dropUp);\n    }\n    positionElement(left = this.coords.left, top = this.coords.top, dropUp = this.dropUp) {\n        const el = this.element.nativeElement;\n        top += dropUp ? 0 : this.offset; // top of list is next line\n        el.className = dropUp ? 'dropup' : null;\n        el.style.position = \"absolute\";\n        el.style.left = left + 'px';\n        el.style.top = top + 'px';\n    }\n    getBlockCursorDimensions(nativeParentElement) {\n        const parentStyles = window.getComputedStyle(nativeParentElement);\n        return {\n            height: parseFloat(parentStyles.lineHeight),\n            width: parseFloat(parentStyles.fontSize)\n        };\n    }\n}\nMentionListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'mention-list',\n                template: `\n    <ng-template #defaultItemTemplate let-item=\"item\">\n      {{item[labelKey]}}\n    </ng-template>\n    <ul #list [hidden]=\"hidden\" class=\"dropdown-menu scrollable-menu\"\n      [class.mention-menu]=\"!styleOff\" [class.mention-dropdown]=\"!styleOff && dropUp\">\n      <li *ngFor=\"let item of items; let i = index\"\n        [class.active]=\"activeIndex==i\" [class.mention-active]=\"!styleOff && activeIndex==i\">\n        <a class=\"dropdown-item\" [class.mention-item]=\"!styleOff\"\n          (mousedown)=\"activeIndex=i;itemClick.emit();$event.preventDefault()\">\n          <ng-template [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{'item':item}\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    `,\n                styles: [\".mention-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:11em;padding:.5em 0;margin:.125em 0 0;font-size:1em;color:#212529;text-align:left;list-style:none;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);border-radius:.25em}.mention-item{display:block;padding:.2em 1.5em;line-height:1.5em;clear:both;font-weight:400;color:#212529;text-align:inherit;white-space:nowrap;background-color:transparent;border:0}.mention-active>a{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.scrollable-menu{display:block;height:auto;max-height:292px;overflow:auto}[hidden]{display:none}.mention-dropdown{bottom:100%;top:auto;margin-bottom:2px}\"]\n            },] }\n];\nMentionListComponent.ctorParameters = () => [\n    { type: ElementRef }\n];\nMentionListComponent.propDecorators = {\n    labelKey: [{ type: Input }],\n    itemTemplate: [{ type: Input }],\n    itemClick: [{ type: Output }],\n    list: [{ type: ViewChild, args: ['list', { static: true },] }],\n    defaultItemTemplate: [{ type: ViewChild, args: ['defaultItemTemplate', { static: true },] }]\n};\n\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_BUFFERED = 229;\n/**\n * Angular Mentions.\n * https://github.com/dmacfarlane/angular-mentions\n *\n * Copyright (c) 2017 Dan MacFarlane\n */\nclass MentionDirective {\n    constructor(_element, _componentResolver, _viewContainerRef) {\n        this._element = _element;\n        this._componentResolver = _componentResolver;\n        this._viewContainerRef = _viewContainerRef;\n        // the provided configuration object\n        this.mentionConfig = { items: [] };\n        this.DEFAULT_CONFIG = {\n            items: [],\n            triggerChar: '@',\n            labelKey: 'label',\n            maxItems: -1,\n            allowSpace: false,\n            returnTrigger: false,\n            mentionSelect: (item, triggerChar) => {\n                return this.activeConfig.triggerChar + item[this.activeConfig.labelKey];\n            },\n            mentionFilter: (searchString, items) => {\n                const searchStringLowerCase = searchString.toLowerCase();\n                return items.filter(e => e[this.activeConfig.labelKey].toLowerCase().startsWith(searchStringLowerCase));\n            }\n        };\n        // event emitted whenever the search term changes\n        this.searchTerm = new EventEmitter();\n        // event emitted when an item is selected\n        this.itemSelected = new EventEmitter();\n        // event emitted whenever the mention list is opened or closed\n        this.opened = new EventEmitter();\n        this.closed = new EventEmitter();\n        this.triggerChars = {};\n    }\n    set mention(items) {\n        this.mentionItems = items;\n    }\n    ngOnChanges(changes) {\n        // console.log('config change', changes);\n        if (changes['mention'] || changes['mentionConfig']) {\n            this.updateConfig();\n        }\n    }\n    updateConfig() {\n        let config = this.mentionConfig;\n        this.triggerChars = {};\n        // use items from directive if they have been set\n        if (this.mentionItems) {\n            config.items = this.mentionItems;\n        }\n        this.addConfig(config);\n        // nested configs\n        if (config.mentions) {\n            config.mentions.forEach(config => this.addConfig(config));\n        }\n    }\n    // add configuration for a trigger char\n    addConfig(config) {\n        // defaults\n        let defaults = Object.assign({}, this.DEFAULT_CONFIG);\n        config = Object.assign(defaults, config);\n        // items\n        let items = config.items;\n        if (items && items.length > 0) {\n            // convert strings to objects\n            if (typeof items[0] == 'string') {\n                items = items.map((label) => {\n                    let object = {};\n                    object[config.labelKey] = label;\n                    return object;\n                });\n            }\n            if (config.labelKey) {\n                // remove items without an labelKey (as it's required to filter the list)\n                items = items.filter(e => e[config.labelKey]);\n                if (!config.disableSort) {\n                    items.sort((a, b) => a[config.labelKey].localeCompare(b[config.labelKey]));\n                }\n            }\n        }\n        config.items = items;\n        // add the config\n        this.triggerChars[config.triggerChar] = config;\n        // for async update while menu/search is active\n        if (this.activeConfig && this.activeConfig.triggerChar == config.triggerChar) {\n            this.activeConfig = config;\n            this.updateSearchList();\n        }\n    }\n    setIframe(iframe) {\n        this.iframe = iframe;\n    }\n    stopEvent(event) {\n        //if (event instanceof KeyboardEvent) { // does not work for iframe\n        if (!event.wasClick) {\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n        }\n    }\n    blurHandler(event) {\n        this.stopEvent(event);\n        this.stopSearch();\n    }\n    inputHandler(event, nativeElement = this._element.nativeElement) {\n        if (this.lastKeyCode === KEY_BUFFERED && event.data) {\n            let keyCode = event.data.charCodeAt(0);\n            this.keyHandler({ keyCode, inputEvent: true }, nativeElement);\n        }\n    }\n    // @param nativeElement is the alternative text element in an iframe scenario\n    keyHandler(event, nativeElement = this._element.nativeElement) {\n        this.lastKeyCode = event.keyCode;\n        if (event.isComposing || event.keyCode === KEY_BUFFERED) {\n            return;\n        }\n        let val = getValue(nativeElement);\n        let pos = getCaretPosition(nativeElement, this.iframe);\n        let charPressed = event.key;\n        if (!charPressed) {\n            let charCode = event.which || event.keyCode;\n            if (!event.shiftKey && (charCode >= 65 && charCode <= 90)) {\n                charPressed = String.fromCharCode(charCode + 32);\n            }\n            // else if (event.shiftKey && charCode === KEY_2) {\n            //   charPressed = this.config.triggerChar;\n            // }\n            else {\n                // TODO (dmacfarlane) fix this for non-alpha keys\n                // http://stackoverflow.com/questions/2220196/how-to-decode-character-pressed-from-jquerys-keydowns-event-handler?lq=1\n                charPressed = String.fromCharCode(event.which || event.keyCode);\n            }\n        }\n        if (event.keyCode == KEY_ENTER && event.wasClick && pos < this.startPos) {\n            // put caret back in position prior to contenteditable menu click\n            pos = this.startNode.length;\n            setCaretPosition(this.startNode, pos, this.iframe);\n        }\n        //console.log(\"keyHandler\", this.startPos, pos, val, charPressed, event);\n        let config = this.triggerChars[charPressed];\n        if (config) {\n            this.activeConfig = config;\n            this.startPos = event.inputEvent ? pos - 1 : pos;\n            this.startNode = (this.iframe ? this.iframe.contentWindow.getSelection() : window.getSelection()).anchorNode;\n            this.searching = true;\n            this.searchString = null;\n            this.showSearchList(nativeElement);\n            this.updateSearchList();\n            if (config.returnTrigger) {\n                this.searchTerm.emit(config.triggerChar);\n            }\n        }\n        else if (this.startPos >= 0 && this.searching) {\n            if (pos <= this.startPos) {\n                this.searchList.hidden = true;\n            }\n            // ignore shift when pressed alone, but not when used with another key\n            else if (event.keyCode !== KEY_SHIFT &&\n                !event.metaKey &&\n                !event.altKey &&\n                !event.ctrlKey &&\n                pos > this.startPos) {\n                if (!this.activeConfig.allowSpace && event.keyCode === KEY_SPACE) {\n                    this.startPos = -1;\n                }\n                else if (event.keyCode === KEY_BACKSPACE && pos > 0) {\n                    pos--;\n                    if (pos == this.startPos) {\n                        this.stopSearch();\n                    }\n                }\n                else if (this.searchList.hidden) {\n                    if (event.keyCode === KEY_TAB || event.keyCode === KEY_ENTER) {\n                        this.stopSearch();\n                        return;\n                    }\n                }\n                else if (!this.searchList.hidden) {\n                    if (event.keyCode === KEY_TAB || event.keyCode === KEY_ENTER) {\n                        this.stopEvent(event);\n                        // emit the selected list item\n                        this.itemSelected.emit(this.searchList.activeItem);\n                        // optional function to format the selected item before inserting the text\n                        const text = this.activeConfig.mentionSelect(this.searchList.activeItem, this.activeConfig.triggerChar);\n                        // value is inserted without a trailing space for consistency\n                        // between element types (div and iframe do not preserve the space)\n                        insertValue(nativeElement, this.startPos, pos, text, this.iframe);\n                        // fire input event so angular bindings are updated\n                        if (\"createEvent\" in document) {\n                            let evt = document.createEvent(\"HTMLEvents\");\n                            if (this.iframe) {\n                                // a 'change' event is required to trigger tinymce updates\n                                evt.initEvent(\"change\", true, false);\n                            }\n                            else {\n                                evt.initEvent(\"input\", true, false);\n                            }\n                            // this seems backwards, but fire the event from this elements nativeElement (not the\n                            // one provided that may be in an iframe, as it won't be propogate)\n                            this._element.nativeElement.dispatchEvent(evt);\n                        }\n                        this.startPos = -1;\n                        this.stopSearch();\n                        return false;\n                    }\n                    else if (event.keyCode === KEY_ESCAPE) {\n                        this.stopEvent(event);\n                        this.stopSearch();\n                        return false;\n                    }\n                    else if (event.keyCode === KEY_DOWN) {\n                        this.stopEvent(event);\n                        this.searchList.activateNextItem();\n                        return false;\n                    }\n                    else if (event.keyCode === KEY_UP) {\n                        this.stopEvent(event);\n                        this.searchList.activatePreviousItem();\n                        return false;\n                    }\n                }\n                if (charPressed.length != 1 && event.keyCode != KEY_BACKSPACE) {\n                    this.stopEvent(event);\n                    return false;\n                }\n                else if (this.searching) {\n                    let mention = val.substring(this.startPos + 1, pos);\n                    if (event.keyCode !== KEY_BACKSPACE && !event.inputEvent) {\n                        mention += charPressed;\n                    }\n                    this.searchString = mention;\n                    if (this.activeConfig.returnTrigger) {\n                        const triggerChar = (this.searchString || event.keyCode === KEY_BACKSPACE) ? val.substring(this.startPos, this.startPos + 1) : '';\n                        this.searchTerm.emit(triggerChar + this.searchString);\n                    }\n                    else {\n                        this.searchTerm.emit(this.searchString);\n                    }\n                    this.updateSearchList();\n                }\n            }\n        }\n    }\n    // exposed for external calls to open the mention list, e.g. by clicking a button\n    startSearch(triggerChar, nativeElement = this._element.nativeElement) {\n        triggerChar = triggerChar || this.mentionConfig.triggerChar || this.DEFAULT_CONFIG.triggerChar;\n        const pos = getCaretPosition(nativeElement, this.iframe);\n        insertValue(nativeElement, pos, pos, triggerChar, this.iframe);\n        this.keyHandler({ key: triggerChar, inputEvent: true }, nativeElement);\n    }\n    stopSearch() {\n        if (this.searchList && !this.searchList.hidden) {\n            this.searchList.hidden = true;\n            this.closed.emit();\n        }\n        this.activeConfig = null;\n        this.searching = false;\n    }\n    updateSearchList() {\n        let matches = [];\n        if (this.activeConfig && this.activeConfig.items) {\n            let objects = this.activeConfig.items;\n            // disabling the search relies on the async operation to do the filtering\n            if (!this.activeConfig.disableSearch && this.searchString && this.activeConfig.labelKey) {\n                if (this.activeConfig.mentionFilter) {\n                    objects = this.activeConfig.mentionFilter(this.searchString, objects);\n                }\n            }\n            matches = objects;\n            if (this.activeConfig.maxItems > 0) {\n                matches = matches.slice(0, this.activeConfig.maxItems);\n            }\n        }\n        // update the search list\n        if (this.searchList) {\n            this.searchList.items = matches;\n            this.searchList.hidden = matches.length == 0;\n        }\n    }\n    showSearchList(nativeElement) {\n        this.opened.emit();\n        if (this.searchList == null) {\n            let componentFactory = this._componentResolver.resolveComponentFactory(MentionListComponent);\n            let componentRef = this._viewContainerRef.createComponent(componentFactory);\n            this.searchList = componentRef.instance;\n            this.searchList.itemTemplate = this.mentionListTemplate;\n            componentRef.instance['itemClick'].subscribe(() => {\n                nativeElement.focus();\n                let fakeKeydown = { key: 'Enter', keyCode: KEY_ENTER, wasClick: true };\n                this.keyHandler(fakeKeydown, nativeElement);\n            });\n        }\n        this.searchList.labelKey = this.activeConfig.labelKey;\n        this.searchList.dropUp = this.activeConfig.dropUp;\n        this.searchList.styleOff = this.mentionConfig.disableStyle;\n        this.searchList.activeIndex = 0;\n        this.searchList.position(nativeElement, this.iframe);\n        window.requestAnimationFrame(() => this.searchList.reset());\n    }\n}\nMentionDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[mention], [mentionConfig]',\n                host: {\n                    '(keydown)': 'keyHandler($event)',\n                    '(input)': 'inputHandler($event)',\n                    '(blur)': 'blurHandler($event)',\n                    'autocomplete': 'off'\n                }\n            },] }\n];\nMentionDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ComponentFactoryResolver },\n    { type: ViewContainerRef }\n];\nMentionDirective.propDecorators = {\n    mention: [{ type: Input, args: ['mention',] }],\n    mentionConfig: [{ type: Input }],\n    mentionListTemplate: [{ type: Input }],\n    searchTerm: [{ type: Output }],\n    itemSelected: [{ type: Output }],\n    opened: [{ type: Output }],\n    closed: [{ type: Output }]\n};\n\nclass MentionModule {\n}\nMentionModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    MentionDirective,\n                    MentionListComponent\n                ],\n                imports: [\n                    CommonModule\n                ],\n                exports: [\n                    MentionDirective\n                ],\n                entryComponents: [\n                    MentionListComponent\n                ]\n            },] }\n];\n\n/*\n * Public API Surface of angular-mentions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MentionDirective, MentionModule, MentionListComponent as ɵa };\n//# sourceMappingURL=angular-mentions.js.map\n"],"sourceRoot":"webpack:///"}